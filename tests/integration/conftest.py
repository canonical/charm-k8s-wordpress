# Copyright 2023 Canonical Ltd.
# See LICENSE file for licensing details.

"""Fixtures for WordPress charm integration tests."""

import asyncio
import configparser
import logging
import pathlib
import re
import typing

import pytest
import pytest_asyncio
import swiftclient
import swiftclient.exceptions
import swiftclient.service
from juju.application import Application
from juju.unit import Unit
from kubernetes import kubernetes
from kubernetes.client import CoreV1Api, NetworkingV1Api
from ops.model import ActiveStatus
from pytest_operator.plugin import OpsTest

from .types_ import DatabaseConfig

logger = logging.getLogger()


@pytest.fixture(scope="module", name="application_name")
def fixture_application_name():
    """Default application name."""
    return "wordpress"


@pytest.fixture(scope="module", name="openstack_environment")
def openstack_environment_fixture(request):
    """Parse the openstack rc style configuration file from the --openstack-rc argument.

    Returns: a dictionary of environment variables and values, or None if --openstack-rc isn't
        provided.
    """
    rc_file = request.config.getoption("--openstack-rc")
    assert rc_file, (
        "swift plugin is required for multi-unit deployment, "
        "please include an openstack configuration in the --openstack-rc parameter "
    )
    if not rc_file:
        return None
    with open(rc_file, encoding="utf-8") as rc_fo:
        rc_file = rc_fo.read()
    rc_file = re.sub("^export ", "", rc_file, flags=re.MULTILINE)
    openstack_conf = configparser.ConfigParser()
    openstack_conf.read_string("[DEFAULT]\n" + rc_file)
    return {k.upper(): v for k, v in openstack_conf["DEFAULT"].items()}


@pytest.fixture
def akismet_api_key(request):
    """The Akismet API key, in str."""
    api_key = request.config.getoption("--akismet-api-key")
    assert (
        api_key
    ), "Akismet API key should not be empty, please include it in the --akismet-api-key parameter"
    return api_key


@pytest.fixture(name="openid_username")
def openid_username_fixture(request):
    """The OpenID username for testing the OpenID plugin."""
    openid_username = request.config.getoption("--openid-username")
    assert (
        openid_username
    ), "OpenID username should not be empty, please include it in the --openid-username parameter"
    return openid_username


@pytest.fixture(name="openid_password")
def openid_password_fixture(request):
    """The OpenID username for testing the OpenID plugin."""
    openid_password = request.config.getoption("--openid-password")
    assert (
        openid_password
    ), "OpenID password should not be empty, please include it in the --openid-password parameter"
    return openid_password


@pytest.fixture(scope="module", name="launchpad_team")
def launchpad_team_fixture(request):
    """The launchpad team for the OpenID account."""
    launchpad_team = request.config.getoption("--launchpad-team")
    assert (
        launchpad_team
    ), "Launchpad team should not be empty, please include it in the --launchpad-team parameter"
    return launchpad_team


@pytest.fixture(scope="module", name="kube_config")
def kube_config_fixture(request):
    """The Kubernetes cluster configuration file."""
    kube_config = request.config.getoption("--kube-config")
    assert kube_config, (
        "The Kubernetes config file path should not be empty, "
        "please include it in the --kube-config parameter"
    )
    return kube_config


@pytest.fixture(scope="module", name="db_from_config")
def db_from_config_fixture(request):
    """Whether to use database configuration config file or from relation."""
    return request.config.getoption("--test-db-from-config")


@pytest.fixture(scope="module", name="screenshot_dir")
def screenshot_dir_fixture(request):
    """A directory to store screenshots generated by test_upgrade."""
    screenshot_dir = request.config.getoption("--screenshot-dir")
    assert screenshot_dir, (
        "Screenshot directory should not be empty, "
        "please include it in the --screenshot-dir parameter"
    )
    return pathlib.Path(screenshot_dir)


@pytest.fixture(scope="module", name="wordpress_image")
def wordpress_image_fixture(request):
    """Wordpress docker image built for the WordPress charm."""
    return request.config.getoption("--wordpress-image")


@pytest_asyncio.fixture(scope="module", name="charm_path")
async def charm_path_fixture(ops_test: OpsTest, request: pytest.FixtureRequest):
    """Path to packed charm, ready for deployment."""
    input_path = str(request.config.getoption("--wordpress-charm-path"))
    if input_path:
        return pathlib.Path(input_path)
    return await ops_test.build_charm(".")


@pytest.fixture(scope="module", name="kube_core_client")
def kube_core_client_fixture(kube_config) -> CoreV1Api:
    """Create a kubernetes client for core API v1."""
    kubernetes.config.load_kube_config(config_file=kube_config)
    kubernetes_client_v1 = kubernetes.client.CoreV1Api()
    return kubernetes_client_v1


@pytest.fixture(name="kube_networking_client")
def kube_networking_client_fixture(kube_config) -> NetworkingV1Api:
    """Create a kubernetes client for networking API v1."""
    kubernetes.config.load_kube_config(config_file=kube_config)
    kubernetes_client_v1 = kubernetes.client.NetworkingV1Api()
    return kubernetes_client_v1


@pytest.fixture(scope="module", name="pod_db_config")
def pod_db_config_fixture() -> DatabaseConfig:
    """MYSQL database configurations and credentials to create3 test database pod."""
    return DatabaseConfig(name="wordpress", user="wordpress", password="wordpress-password")


@pytest_asyncio.fixture(name="deploy_app_num_units")
async def deploy_app_num_units_fixture(
    ops_test: OpsTest,
    charm_path: pathlib.Path,
    wordpress_image: str,
) -> typing.Callable[[int, str], typing.Awaitable[Application]]:
    """Deploy given number of WordPress application units."""

    async def deploy_num_units(num_units: int, app_name: str):
        """Deploy num_units of WordPress application.


        Args:
            num_units: number of WordPress units to deploy as a cluster.
            app_name: name of juju application to deploy WordPress under.

        Returns:
            Wordpress application.
        """
        assert ops_test.model
        resources = {"wordpress-image": wordpress_image}
        app: Application = await ops_test.model.deploy(
            charm_path,
            application_name=app_name,
            resources=resources,
            series="jammy",
            num_units=num_units,
        )
        await ops_test.model.wait_for_idle(apps=[app_name])
        return app

    return deploy_num_units


@pytest_asyncio.fixture(scope="module", name="mariadb")
async def mariadb_fixture(ops_test: OpsTest) -> Application:
    # D403: MariaDB is properly capitalized
    """MariaDB k8s charm that provides mysql relation interface."""  # noqa: D403
    assert ops_test.model
    return await ops_test.model.deploy("charmed-osm-mariadb-k8s", application_name="mariadb")


@pytest_asyncio.fixture(scope="module", name="nginx")
async def nginx_fixture(ops_test: OpsTest) -> Application:
    """Nginx ingress integrator charm that provides ingress relation interface."""
    assert ops_test.model
    # temporary fix for the CharmHub problem
    return await ops_test.model.deploy(
        "nginx-ingress-integrator",
        channel="edge",
        series="focal",
        trust=True,
        application_name="nginx",
    )


@pytest_asyncio.fixture(scope="module", name="app")
async def app_fixture(
    ops_test: OpsTest,
    charm_path: pathlib.Path,
    application_name: str,
    wordpress_image: str,
    mariadb: Application,
    nginx: Application,
):
    # D403: WordPress is correctly capitalized.
    """WordPress charm used for integration testing.

    Builds the charm and deploys it and the relations it depends on. Uses database from relation.
    """  # noqa: D403
    assert ops_test.model

    # Build and deploy WordPress charm
    resources = {"wordpress-image": wordpress_image}
    app: Application = await ops_test.model.deploy(
        charm_path,
        resources=resources,
        application_name=application_name,
        series="jammy",
        num_units=3,
    )
    await ops_test.model.wait_for_idle()

    # Add necessary relations
    await asyncio.gather(
        ops_test.model.add_relation(application_name, mariadb.name),
        ops_test.model.add_relation(application_name, nginx.name),
    )
    await ops_test.model.wait_for_idle(apps=[application_name], status="active")
    unit: Unit = app.units[0]
    # mypy has trouble to inferred types for variables that are initialized in subclasses.
    assert unit.workload_status == ActiveStatus.name  # type: ignore

    yield app


@pytest.fixture(scope="module", name="swift_conn")
def swift_conn_fixture(openstack_environment):
    """Create a swift connection client."""
    if openstack_environment is None:
        return None
    swift_conn = swiftclient.Connection(
        authurl=openstack_environment["OS_AUTH_URL"],
        auth_version="3",
        user=openstack_environment["OS_USERNAME"],
        key=openstack_environment["OS_PASSWORD"],
        os_options={
            "user_domain_name": openstack_environment["OS_USER_DOMAIN_ID"],
            "project_domain_name": openstack_environment["OS_PROJECT_DOMAIN_ID"],
            "project_name": openstack_environment["OS_PROJECT_NAME"],
        },
    )
    return swift_conn


@pytest.fixture(scope="module", name="swift_config")
def swift_config_fixture(
    request: pytest.FixtureRequest,
    swift_conn: swiftclient.Connection,
    openstack_environment: typing.Optional[typing.Dict[str, str]],
) -> typing.Optional[typing.Dict[str, str]]:
    """Create a swift config dict that can be used for wp_plugin_openstack-objectstorage_config."""
    if openstack_environment is None:
        return None
    swift_service = swiftclient.service.SwiftService(
        options={
            "auth_version": "3",
            "os_auth_url": openstack_environment["OS_AUTH_URL"],
            "os_username": openstack_environment["OS_USERNAME"],
            "os_password": openstack_environment["OS_PASSWORD"],
            "os_project_name": openstack_environment["OS_PROJECT_NAME"],
            "os_project_domain_name": openstack_environment["OS_PROJECT_DOMAIN_ID"],
        }
    )
    container = f"wordpress_{request.module.__name__.split('.')[-1]}"
    logger.info("Use container %s", container)
    # if the container exists, remove the container
    swift_service.delete(container=container)
    # create a swift container for our test
    swift_conn.put_container(container)
    # change container ACL to allow us getting an object by HTTP request without any authentication
    # the swift server will act as a static HTTP server after this
    swift_service.post(container=container, options={"read_acl": ".r:*,.rlistings"})

    return {
        "auth-url": openstack_environment["OS_AUTH_URL"] + "/v3",
        "bucket": container,
        "password": openstack_environment["OS_PASSWORD"],
        "object-prefix": "wp-content/uploads/",
        "region": openstack_environment["OS_REGION_NAME"],
        "tenant": openstack_environment["OS_PROJECT_NAME"],
        "domain": openstack_environment["OS_PROJECT_DOMAIN_ID"],
        "swift-url": swift_conn.url,
        "username": openstack_environment["OS_USERNAME"],
        "copy-to-swift": "1",
        "serve-from-swift": "1",
        "remove-local-file": "0",
    }
